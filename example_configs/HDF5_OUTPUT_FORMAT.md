# HDF5 Output File Format Documentation

This document describes the HDF5 file structure for all output types generated by the unified simulation framework.

## Table of Contents
- [Molecular Dynamics (Standard Lattice)](#molecular-dynamics-standard-lattice)
- [Molecular Dynamics (Mixed SU(2)/SU(3) Lattice)](#molecular-dynamics-mixed-su2su3-lattice)
- [Pump-Probe Spectroscopy](#pump-probe-spectroscopy)
- [Pump-Probe Spectroscopy (Mixed Lattice)](#pump-probe-spectroscopy-mixed-lattice)
- [Reading HDF5 Files](#reading-hdf5-files)

---

## Molecular Dynamics (Standard Lattice)

**File format:** `HDF5_MD_v1.0`  
**Writer class:** `HDF5MDWriter`  
**Typical filename:** `md_trajectory.h5`, `BCAO_md.h5`, `kitaev_md.h5`, etc.

### File Structure

```
/
├── metadata/                    [GROUP]
│   ├── lattice_size            [ATTRIBUTE: hsize_t] - Total number of sites
│   ├── spin_dim                [ATTRIBUTE: hsize_t] - Spin vector dimension (3 for SU(2), 8 for SU(3))
│   ├── n_atoms                 [ATTRIBUTE: hsize_t] - Atoms per unit cell
│   ├── dimensions              [DATASET: (3,)] - Lattice size (Lx, Ly, Lz)
│   ├── integration_method      [ATTRIBUTE: string] - ODE solver ("rk4", "dopri5", "verlet")
│   ├── dt_initial              [ATTRIBUTE: double] - Initial timestep
│   ├── T_start                 [ATTRIBUTE: double] - Start time
│   ├── T_end                   [ATTRIBUTE: double] - End time
│   ├── save_interval           [ATTRIBUTE: hsize_t] - Steps between saves
│   ├── spin_length             [ATTRIBUTE: double] - Spin magnitude
│   ├── creation_time           [ATTRIBUTE: string] - ISO 8601 timestamp
│   ├── code_version            [ATTRIBUTE: string] - "ClassicalSpin_Cpp v1.0"
│   ├── file_format             [ATTRIBUTE: string] - "HDF5_MD_v1.0"
│   └── positions (optional)    [DATASET: (lattice_size, 3)] - Site positions
│
└── trajectory/                  [GROUP]
    ├── times                    [DATASET: (n_steps,)] - Time points
    ├── spins                    [DATASET: (n_steps, lattice_size, spin_dim)] - Full spin configurations
    ├── magnetization_antiferro  [DATASET: (n_steps, spin_dim)] - Antiferromagnetic order parameter
    └── magnetization_local      [DATASET: (n_steps, spin_dim)] - Local magnetization
```

### Dataset Details

#### `/trajectory/times`
- **Shape:** `(n_steps,)`
- **Type:** `double`
- **Units:** Natural time units (typically ℏ/J)
- **Description:** Time points at which trajectory data was saved

#### `/trajectory/spins`
- **Shape:** `(n_steps, lattice_size, spin_dim)`
- **Type:** `double`
- **Description:** Complete spin configuration at each time step
  - For SU(2): `spin_dim = 3`, entries are (Sx, Sy, Sz)
  - For SU(3): `spin_dim = 8`, entries are Gell-Mann matrix components (λ1, λ2, ..., λ8)
- **Compression:** Deflate level 6
- **Note:** Can be very large; consider subsampling for long trajectories

#### `/trajectory/magnetization_antiferro`
- **Shape:** `(n_steps, spin_dim)`
- **Type:** `double`
- **Description:** Antiferromagnetic order parameter
  - Defined as sublattice magnetization difference
  - For honeycomb: M_A - M_B
  - Normalized by number of sublattice sites

#### `/trajectory/magnetization_local`
- **Shape:** `(n_steps, spin_dim)`
- **Type:** `double`
- **Description:** Local/uniform magnetization (total magnetization per site)

### Example: Reading MD File (Python)

```python
import h5py
import numpy as np
import matplotlib.pyplot as plt

# Open file
with h5py.File('BCAO_md.h5', 'r') as f:
    # Read metadata
    lattice_size = f['metadata'].attrs['lattice_size']
    spin_dim = f['metadata'].attrs['spin_dim']
    print(f"Lattice size: {lattice_size}, Spin dim: {spin_dim}")
    
    # Read trajectory
    times = f['trajectory/times'][:]
    mag_af = f['trajectory/magnetization_antiferro'][:]
    
    # Plot antiferromagnetic order vs time
    plt.plot(times, np.linalg.norm(mag_af, axis=1))
    plt.xlabel('Time')
    plt.ylabel('|M_antiferro|')
    plt.show()
    
    # Read specific time slice of spins (avoid loading all at once!)
    t_idx = 100
    spins_at_t = f['trajectory/spins'][t_idx, :, :]  # Shape: (lattice_size, spin_dim)
```

---

## Molecular Dynamics (Mixed SU(2)/SU(3) Lattice)

**File format:** `HDF5_Mixed_MD_v1.0`  
**Writer class:** `HDF5MixedMDWriter`  
**Use case:** TmFeO3 (Fe=SU(2), Tm=SU(3))

### File Structure

```
/
├── metadata_global/             [GROUP]
│   ├── integration_method      [ATTRIBUTE: string]
│   ├── dt_initial              [ATTRIBUTE: double]
│   ├── T_start, T_end          [ATTRIBUTE: double]
│   ├── save_interval           [ATTRIBUTE: hsize_t]
│   ├── dimensions              [DATASET: (3,)] - (Lx, Ly, Lz)
│   ├── creation_time           [ATTRIBUTE: string]
│   ├── code_version            [ATTRIBUTE: string]
│   └── file_format             [ATTRIBUTE: string] - "HDF5_Mixed_MD_v1.0"
│
├── metadata_SU2/                [GROUP]
│   ├── lattice_size            [ATTRIBUTE: hsize_t]
│   ├── spin_dim                [ATTRIBUTE: hsize_t] - Usually 3
│   ├── n_atoms                 [ATTRIBUTE: hsize_t]
│   ├── spin_length             [ATTRIBUTE: double]
│   └── positions (optional)    [DATASET: (lattice_size_SU2, 3)]
│
├── metadata_SU3/                [GROUP]
│   ├── lattice_size            [ATTRIBUTE: hsize_t]
│   ├── spin_dim                [ATTRIBUTE: hsize_t] - Usually 8
│   ├── n_atoms                 [ATTRIBUTE: hsize_t]
│   ├── spin_length             [ATTRIBUTE: double]
│   └── positions (optional)    [DATASET: (lattice_size_SU3, 3)]
│
├── trajectory_SU2/              [GROUP]
│   ├── times                   [DATASET: (n_steps,)]
│   ├── spins                   [DATASET: (n_steps, lattice_size_SU2, spin_dim_SU2)]
│   ├── magnetization_antiferro [DATASET: (n_steps, spin_dim_SU2)]
│   └── magnetization_local     [DATASET: (n_steps, spin_dim_SU2)]
│
└── trajectory_SU3/              [GROUP]
    ├── times                   [DATASET: (n_steps,)]
    ├── spins                   [DATASET: (n_steps, lattice_size_SU3, spin_dim_SU3)]
    ├── magnetization_antiferro [DATASET: (n_steps, spin_dim_SU3)]
    └── magnetization_local     [DATASET: (n_steps, spin_dim_SU3)]
```

### Example: Reading Mixed Lattice File (Python)

```python
import h5py
import numpy as np

with h5py.File('TmFeO3_md.h5', 'r') as f:
    # Read SU(2) data (Fe spins)
    times_SU2 = f['trajectory_SU2/times'][:]
    spins_Fe = f['trajectory_SU2/spins'][:]  # Shape: (n_steps, n_Fe_sites, 3)
    
    # Read SU(3) data (Tm spins)
    times_SU3 = f['trajectory_SU3/times'][:]
    spins_Tm = f['trajectory_SU3/spins'][:]  # Shape: (n_steps, n_Tm_sites, 8)
    
    # Both should have same time grid
    assert np.allclose(times_SU2, times_SU3)
    
    # Analyze Fe magnetization
    mag_Fe = f['trajectory_SU2/magnetization_antiferro'][:]
    print(f"Fe magnetization at t=0: {mag_Fe[0]}")
    
    # Analyze Tm quadrupole moments (Gell-Mann components)
    mag_Tm = f['trajectory_SU3/magnetization_local'][:]
    print(f"Tm Gell-Mann components at t=0: {mag_Tm[0]}")
```

---

## Pump-Probe Spectroscopy

**File format:** `HDF5_PumpProbe_v1.0`  
**Writer class:** `HDF5PumpProbeWriter`  
**Experiments:** 2DCS, delay-dependent magnetization dynamics

### File Structure

```
/
├── metadata/                    [GROUP]
│   ├── creation_time           [ATTRIBUTE: string]
│   ├── experiment_type         [ATTRIBUTE: string] - "pump_probe_spectroscopy"
│   ├── code_version            [ATTRIBUTE: string]
│   ├── file_format             [ATTRIBUTE: string] - "HDF5_PumpProbe_v1.0"
│   │
│   ├── [Lattice parameters]
│   ├── lattice_size, spin_dim, n_atoms [ATTRIBUTE: hsize_t]
│   ├── dim1, dim2, dim3        [ATTRIBUTE: hsize_t]
│   ├── spin_length             [ATTRIBUTE: double]
│   ├── positions (optional)    [DATASET: (lattice_size, 3)]
│   │
│   ├── [Pulse parameters]
│   ├── pulse_amp               [ATTRIBUTE: double] - Pulse amplitude
│   ├── pulse_width             [ATTRIBUTE: double] - Pulse temporal width (σ)
│   ├── pulse_freq              [ATTRIBUTE: double] - Pulse frequency (ω)
│   ├── pulse_field_direction (optional) [DATASET: (n_atoms, spin_dim)]
│   │
│   ├── [Time evolution]
│   ├── T_start, T_end, T_step  [ATTRIBUTE: double]
│   ├── integration_method      [ATTRIBUTE: string]
│   │
│   ├── [Delay scan parameters]
│   ├── tau_start, tau_end      [ATTRIBUTE: double] - Delay scan range
│   ├── tau_step                [ATTRIBUTE: double] - Delay step size
│   ├── tau_steps               [ATTRIBUTE: int] - Number of delay points
│   │
│   └── [Ground state]
│       ├── ground_state_energy            [ATTRIBUTE: double]
│       ├── ground_state_magnetization     [ATTRIBUTE: double]
│       ├── Temp_start, Temp_end           [ATTRIBUTE: double]
│       ├── n_anneal                       [ATTRIBUTE: hsize_t]
│       ├── T_zero_quench                  [ATTRIBUTE: string] - "true"/"false"
│       └── quench_sweeps (if quench)      [ATTRIBUTE: hsize_t]
│
├── reference/                   [GROUP] - Single pulse response (M0)
│   ├── times                   [DATASET: (n_times,)]
│   ├── M_antiferro             [DATASET: (n_times, spin_dim)]
│   ├── M_local                 [DATASET: (n_times, spin_dim)]
│   └── M_global                [DATASET: (n_times, spin_dim)]
│
└── tau_scan/                    [GROUP]
    ├── tau_values              [DATASET: (n_tau,)] - Array of delay times
    │
    ├── tau_0/                  [GROUP] - First delay point
    │   ├── tau_value           [ATTRIBUTE: double]
    │   ├── M1_antiferro        [DATASET: (n_times, spin_dim)] - Response to second pulse only
    │   ├── M1_local            [DATASET: (n_times, spin_dim)]
    │   ├── M1_global           [DATASET: (n_times, spin_dim)]
    │   ├── M01_antiferro       [DATASET: (n_times, spin_dim)] - Response to both pulses
    │   ├── M01_local           [DATASET: (n_times, spin_dim)]
    │   └── M01_global          [DATASET: (n_times, spin_dim)]
    │
    ├── tau_1/                  [GROUP]
    │   └── ... (same structure)
    │
    └── tau_N/                  [GROUP]
        └── ... (same structure)
```

### Magnetization Types

| Name | Description |
|------|-------------|
| `M_antiferro` | Antiferromagnetic order parameter (sublattice difference) |
| `M_local` | Local/uniform magnetization (per-site average) |
| `M_global` | Global magnetization (total system) |
| `M0` | Reference trajectory (single pulse at t=0) |
| `M1` | Response to second pulse only (first pulse absent) |
| `M01` | Response to both pulses (first at t=0, second at t=τ) |

### 2DCS Signal Calculation

The 2D coherent spectroscopy signal is computed from:

```
Signal(τ, t) = M01(τ, t) - M0(t) - M1(τ, t)
```

This represents the nonlinear interaction between the two pulses.

### Example: Reading Pump-Probe File (Python)

```python
import h5py
import numpy as np
import matplotlib.pyplot as plt

with h5py.File('kitaev_2dcs.h5', 'r') as f:
    # Read metadata
    tau_start = f['metadata'].attrs['tau_start']
    tau_end = f['metadata'].attrs['tau_end']
    tau_step = f['metadata'].attrs['tau_step']
    n_tau = f['metadata'].attrs['tau_steps']
    
    # Read reference trajectory (M0)
    times = f['reference/times'][:]
    M0 = f['reference/M_antiferro'][:]
    
    # Read delay scan data
    tau_values = f['tau_scan/tau_values'][:]
    
    # Extract 2DCS signal for specific delay
    tau_idx = 10
    tau_group = f[f'tau_scan/tau_{tau_idx}']
    tau_val = tau_group.attrs['tau_value']
    
    M1 = tau_group['M1_antiferro'][:]
    M01 = tau_group['M01_antiferro'][:]
    
    # Calculate 2DCS signal
    signal_2dcs = M01 - M0 - M1
    
    # Plot
    fig, axes = plt.subplots(1, 3, figsize=(15, 4))
    axes[0].plot(times, np.linalg.norm(M0, axis=1), label='M0')
    axes[0].set_title('Reference (single pulse)')
    
    axes[1].plot(times, np.linalg.norm(M01, axis=1), label='M01')
    axes[1].set_title(f'Both pulses (τ={tau_val:.2f})')
    
    axes[2].plot(times, np.linalg.norm(signal_2dcs, axis=1))
    axes[2].set_title('2DCS Signal')
    
    plt.tight_layout()
    plt.show()
```

### Example: Computing 2DCS Spectrum (Python)

```python
import h5py
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft2, fftfreq

def compute_2dcs_spectrum(filename):
    """Compute 2D Fourier transform of 2DCS signal."""
    with h5py.File(filename, 'r') as f:
        tau_values = f['tau_scan/tau_values'][:]
        n_tau = len(tau_values)
        
        # Get time grid from first tau point
        times = f['reference/times'][:]
        n_times = len(times)
        M0 = f['reference/M_antiferro'][:]
        
        # Build 2D signal array: Signal[tau_idx, time_idx]
        signal_2d = np.zeros((n_tau, n_times))
        
        for i in range(n_tau):
            tau_group = f[f'tau_scan/tau_{i}']
            M1 = tau_group['M1_antiferro'][:]
            M01 = tau_group['M01_antiferro'][:]
            
            # 2DCS signal (magnitude)
            signal_2dcs = M01 - M0 - M1
            signal_2d[i, :] = np.linalg.norm(signal_2dcs, axis=1)
        
        # 2D Fourier transform
        spectrum_2d = np.abs(fft2(signal_2d))
        
        # Frequency grids
        freq_tau = fftfreq(n_tau, d=tau_values[1] - tau_values[0])
        freq_t = fftfreq(n_times, d=times[1] - times[0])
        
        # Plot
        plt.figure(figsize=(8, 6))
        plt.imshow(spectrum_2d, extent=[freq_t.min(), freq_t.max(), 
                                        freq_tau.min(), freq_tau.max()],
                  aspect='auto', origin='lower', cmap='hot')
        plt.xlabel('Frequency ω_t')
        plt.ylabel('Frequency ω_τ')
        plt.title('2DCS Spectrum')
        plt.colorbar(label='Intensity')
        plt.show()

compute_2dcs_spectrum('kitaev_2dcs.h5')
```

---

## Pump-Probe Spectroscopy (Mixed Lattice)

**File format:** `HDF5_PumpProbe_Mixed_v1.0`  
**Writer class:** `HDF5MixedPumpProbeWriter`  
**Use case:** TmFeO3 2DCS with separate Fe and Tm response

### File Structure

```
/
├── metadata/                    [GROUP]
│   ├── [Standard metadata]
│   ├── experiment_type         [ATTRIBUTE: string] - "pump_probe_spectroscopy_mixed"
│   ├── file_format             [ATTRIBUTE: string] - "HDF5_PumpProbe_Mixed_v1.0"
│   │
│   ├── [SU(2) lattice parameters]
│   ├── lattice_size_SU2, spin_dim_SU2, n_atoms_SU2 [ATTRIBUTE: hsize_t]
│   ├── spin_length_SU2         [ATTRIBUTE: double]
│   ├── pulse_amp_SU2, pulse_width_SU2, pulse_freq_SU2 [ATTRIBUTE: double]
│   ├── ground_state_magnetization_SU2 [ATTRIBUTE: double]
│   ├── positions_SU2 (optional) [DATASET: (lattice_size_SU2, 3)]
│   ├── pulse_field_direction_SU2 (optional) [DATASET: (n_atoms_SU2, spin_dim_SU2)]
│   │
│   ├── [SU(3) lattice parameters]
│   ├── lattice_size_SU3, spin_dim_SU3, n_atoms_SU3 [ATTRIBUTE: hsize_t]
│   ├── spin_length_SU3         [ATTRIBUTE: double]
│   ├── pulse_amp_SU3, pulse_width_SU3, pulse_freq_SU3 [ATTRIBUTE: double]
│   ├── ground_state_magnetization_SU3 [ATTRIBUTE: double]
│   ├── positions_SU3 (optional) [DATASET: (lattice_size_SU3, 3)]
│   ├── pulse_field_direction_SU3 (optional) [DATASET: (n_atoms_SU3, spin_dim_SU3)]
│   │
│   └── [Common parameters: time, delay, ground state, etc.]
│
├── reference/                   [GROUP]
│   ├── times                   [DATASET: (n_times,)]
│   ├── M_antiferro_SU2         [DATASET: (n_times, spin_dim_SU2)]
│   ├── M_local_SU2             [DATASET: (n_times, spin_dim_SU2)]
│   ├── M_global_SU2            [DATASET: (n_times, spin_dim_SU2)]
│   ├── M_antiferro_SU3         [DATASET: (n_times, spin_dim_SU3)]
│   ├── M_local_SU3             [DATASET: (n_times, spin_dim_SU3)]
│   └── M_global_SU3            [DATASET: (n_times, spin_dim_SU3)]
│
└── tau_scan/                    [GROUP]
    ├── tau_values              [DATASET: (n_tau,)]
    │
    └── tau_i/                  [GROUP]
        ├── tau_value           [ATTRIBUTE: double]
        │
        ├── [M1 trajectories - second pulse only]
        ├── M1_antiferro_SU2    [DATASET: (n_times, spin_dim_SU2)]
        ├── M1_local_SU2        [DATASET: (n_times, spin_dim_SU2)]
        ├── M1_global_SU2       [DATASET: (n_times, spin_dim_SU2)]
        ├── M1_antiferro_SU3    [DATASET: (n_times, spin_dim_SU3)]
        ├── M1_local_SU3        [DATASET: (n_times, spin_dim_SU3)]
        ├── M1_global_SU3       [DATASET: (n_times, spin_dim_SU3)]
        │
        ├── [M01 trajectories - both pulses]
        ├── M01_antiferro_SU2   [DATASET: (n_times, spin_dim_SU2)]
        ├── M01_local_SU2       [DATASET: (n_times, spin_dim_SU2)]
        ├── M01_global_SU2      [DATASET: (n_times, spin_dim_SU2)]
        ├── M01_antiferro_SU3   [DATASET: (n_times, spin_dim_SU3)]
        ├── M01_local_SU3       [DATASET: (n_times, spin_dim_SU3)]
        └── M01_global_SU3      [DATASET: (n_times, spin_dim_SU3)]
```

### Example: Reading Mixed Pump-Probe File (Python)

```python
import h5py
import numpy as np
import matplotlib.pyplot as plt

with h5py.File('TmFeO3_2dcs.h5', 'r') as f:
    # Read metadata
    lattice_size_Fe = f['metadata'].attrs['lattice_size_SU2']
    lattice_size_Tm = f['metadata'].attrs['lattice_size_SU3']
    print(f"Fe sites: {lattice_size_Fe}, Tm sites: {lattice_size_Tm}")
    
    # Read reference trajectories
    times = f['reference/times'][:]
    M0_Fe = f['reference/M_antiferro_SU2'][:]  # Fe response (3D)
    M0_Tm = f['reference/M_antiferro_SU3'][:]  # Tm response (8D Gell-Mann)
    
    # Analyze specific delay point
    tau_idx = 15
    tau_group = f[f'tau_scan/tau_{tau_idx}']
    tau_val = tau_group.attrs['tau_value']
    
    # Fe 2DCS signal
    M1_Fe = tau_group['M1_antiferro_SU2'][:]
    M01_Fe = tau_group['M01_antiferro_SU2'][:]
    signal_Fe = M01_Fe - M0_Fe - M1_Fe
    
    # Tm 2DCS signal
    M1_Tm = tau_group['M1_antiferro_SU3'][:]
    M01_Tm = tau_group['M01_antiferro_SU3'][:]
    signal_Tm = M01_Tm - M0_Tm - M1_Tm
    
    # Plot Fe and Tm responses
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))
    
    ax1.plot(times, np.linalg.norm(signal_Fe, axis=1), label='Fe (SU2)')
    ax1.set_xlabel('Time')
    ax1.set_ylabel('|2DCS Signal|')
    ax1.set_title(f'Fe Response (τ={tau_val:.2f})')
    ax1.legend()
    
    ax2.plot(times, np.linalg.norm(signal_Tm, axis=1), label='Tm (SU3)', color='red')
    ax2.set_xlabel('Time')
    ax2.set_ylabel('|2DCS Signal|')
    ax2.set_title(f'Tm Response (τ={tau_val:.2f})')
    ax2.legend()
    
    plt.tight_layout()
    plt.show()
```

---

## Reading HDF5 Files

### Python (h5py)

```python
import h5py

# List all groups and datasets
def print_structure(name, obj):
    print(name)
    if isinstance(obj, h5py.Dataset):
        print(f"  Shape: {obj.shape}, Dtype: {obj.dtype}")

with h5py.File('output.h5', 'r') as f:
    f.visititems(print_structure)
```

### MATLAB

```matlab
% Read HDF5 file
times = h5read('output.h5', '/trajectory/times');
spins = h5read('output.h5', '/trajectory/spins');
mag = h5read('output.h5', '/trajectory/magnetization_antiferro');

% Read attributes
lattice_size = h5readatt('output.h5', '/metadata', 'lattice_size');
```

### Julia

```julia
using HDF5

h5open("output.h5", "r") do file
    times = read(file, "trajectory/times")
    spins = read(file, "trajectory/spins")
    
    # Read attributes
    lattice_size = read_attribute(file["metadata"], "lattice_size")
end
```

### C++ (same library as simulation)

```cpp
#include <H5Cpp.h>

H5::H5File file("output.h5", H5F_ACC_RDONLY);

// Read times
H5::DataSet times_ds = file.openDataSet("/trajectory/times");
H5::DataSpace times_space = times_ds.getSpace();
hsize_t n_steps;
times_space.getSimpleExtentDims(&n_steps);
std::vector<double> times(n_steps);
times_ds.read(times.data(), H5::PredType::NATIVE_DOUBLE);

// Read attribute
H5::Group metadata = file.openGroup("/metadata");
H5::Attribute lattice_attr = metadata.openAttribute("lattice_size");
hsize_t lattice_size;
lattice_attr.read(H5::PredType::NATIVE_HSIZE, &lattice_size);
```

### Command-line Tools

```bash
# List structure
h5ls -r output.h5

# Detailed structure with sizes
h5dump -H output.h5

# Extract specific dataset to text
h5dump -d /trajectory/times output.h5

# Get attribute value
h5dump -a /metadata/lattice_size output.h5
```

---

## Data Compression

All trajectory datasets use **HDF5 deflate compression (level 6)** to reduce file sizes:
- Typical compression ratio: 2-5x for spin configurations
- Lossless compression preserves numerical accuracy
- Slight performance overhead during writing (~10-20%)

Chunking strategy:
- `times`: 1000 time steps per chunk
- `magnetization`: 100 time steps per chunk
- `spins`: 1 time step per chunk (optimized for time-slice access)

---

## File Size Estimates

### Molecular Dynamics

For a trajectory with:
- Lattice size: 1000 sites
- Spin dimension: 3 (SU(2))
- Time steps: 10,000
- Compression ratio: 3x

**Uncompressed:**
- `spins`: 10,000 × 1000 × 3 × 8 bytes = 240 MB
- `magnetization`: 10,000 × 3 × 8 bytes × 2 = 0.48 MB
- **Total:** ~240 MB

**Compressed:** ~80 MB

### Pump-Probe / 2DCS

For a 2DCS scan with:
- Delay points: 100
- Time steps per trajectory: 1000
- Lattice size: 100 sites

**Total:** ~15 MB (compressed)

### Recommendations

- For long trajectories (>100,000 steps), increase `save_interval` to reduce file size
- Use `h5repack` to optimize existing files: `h5repack -f GZIP=6 input.h5 output.h5`
- Store only essential data; full spin configurations can be regenerated if needed

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| v1.0 | 2024 | Initial HDF5 format for unified simulation framework |

